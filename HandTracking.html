<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Particles: Size & Color Control</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; outline: none; }
        #video-container {
            position: absolute;
            top: 10px; left: 10px;
            width: 160px; height: 120px;
            z-index: 10; opacity: 0.7;
            border: 1px solid #555;
            transform: scaleX(-1); /* G∆∞∆°ng video l·∫°i cho thu·∫≠n m·∫Øt */
            border-radius: 8px; overflow: hidden;
        }
        #videoElement { width: 100%; height: 100%; object-fit: cover; }
        #ui {
            position: absolute; top: 20px; right: 20px;
            color: #eee; background: rgba(30, 30, 30, 0.8);
            padding: 20px; border-radius: 12px;
            pointer-events: none; user-select: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        h1 { margin: 0 0 15px 0; font-size: 1.1rem; color: #00d2ff; text-transform: uppercase; letter-spacing: 1px; }
        p { margin: 8px 0; font-size: 0.85rem; line-height: 1.4; }
        .key { color: #ffcc00; font-weight: bold; }
        .action { color: #fff; }
        #status { margin-top: 15px; font-weight: bold; color: #00ff88; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="video-container">
        <video id="videoElement"></video>
    </div>

    <div id="ui">
        <h1>ƒêi·ªÅu Khi·ªÉn B·∫±ng Tay</h1>
        <p>üñê <span class="key">Di chuy·ªÉn tay:</span> V·ªã tr√≠ & M√†u s·∫Øc</p>
        <p>&nbsp;&nbsp;&nbsp;‚ÜîÔ∏è Tr√°i/Ph·∫£i: ƒê·ªïi t√¥ng m√†u (Hue)</p>
        <p>&nbsp;&nbsp;&nbsp;‚ÜïÔ∏è L√™n/Xu·ªëng: ƒê·ªïi ƒë·ªô s√°ng</p>
        <p>üëå <span class="key">Pinch (Ng√≥n tr·ªè+C√°i):</span> K√≠ch c·ª° h·∫°t</p>
        <hr style="border-color: rgba(255,255,255,0.1);">
        <p>‚òùÔ∏è <span class="key">1 Ng√≥n:</span> Kh·ªëi C·∫ßu (Sphere)</p>
        <p>‚úåÔ∏è <span class="key">2 Ng√≥n:</span> Tr√°i Tim (Heart)</p>
        <p>ü§ü <span class="key">3 Ng√≥n:</span> Sao Th·ªï (Saturn)</p>
        <p>üññ <span class="key">4 Ng√≥n:</span> B√¥ng Hoa (Flower)</p>
        <p>üñê <span class="key">5 Ng√≥n:</span> C∆°n B√£o (Torus Storm)</p>
        <p id="status">Tr·∫°ng th√°i: ƒêang t·∫£i camera...</p>
    </div>

<script>
    // --- C·∫§U H√åNH ---
    const PARTICLE_COUNT = 12000; // S·ªë l∆∞·ª£ng h·∫°t
    const BASE_PARTICLE_SIZE = 0.05; // K√≠ch th∆∞·ªõc c∆° b·∫£n
    const LERP_SPEED = 0.06; // T·ªëc ƒë·ªô di chuy·ªÉn h·∫°t (c√†ng cao c√†ng nhanh)

    // --- THREE.JS SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020202);
    scene.fog = new THREE.FogExp2(0x020202, 0.03); // Th√™m s∆∞∆°ng m√π t·∫°o chi·ªÅu s√¢u

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 14;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // T·ªëi ∆∞u hi·ªáu nƒÉng tr√™n m√†n h√¨nh retina
    document.body.appendChild(renderer.domElement);

    // --- H·ªÜ TH·ªêNG H·∫†T (PARTICLE SYSTEM) ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const targets = new Float32Array(PARTICLE_COUNT * 3); // V·ªã tr√≠ m·ª•c ti√™u ƒë·ªÉ bay ƒë·∫øn
    
    // Kh·ªüi t·∫°o v·ªã tr√≠ ng·∫´u nhi√™n ban ƒë·∫ßu
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 20;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 20;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 20;
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // T·∫°o texture h√¨nh tr√≤n m·ªÅm cho h·∫°t
    const getSprite = () => {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        grad.addColorStop(0.1, 'rgba(255,255,255,1)');
        grad.addColorStop(0.5, 'rgba(255,255,255,0.3)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 64, 64);
        return canvas;
    };

    const material = new THREE.PointsMaterial({
        size: BASE_PARTICLE_SIZE,
        color: new THREE.Color(0x00ffff), // M√†u kh·ªüi t·∫°o
        map: new THREE.CanvasTexture(getSprite()),
        blending: THREE.AdditiveBlending, // Pha tr·ªôn m√†u ki·ªÉu ph√°t s√°ng
        depthWrite: false,
        transparent: true
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- C√ÅC H√ÄM T·∫†O H√åNH D√ÅNG (SHAPE GENERATORS) ---
    
    // H√¨nh c·∫ßu
    function sphereShape(i) {
        const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
        const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
        const r = 4;
        return {
            x: r * Math.cos(theta) * Math.sin(phi),
            y: r * Math.sin(theta) * Math.sin(phi),
            z: r * Math.cos(phi)
        };
    }

    // H√¨nh tr√°i tim 3D
    function heartShape(i) {
        const phi = (i / PARTICLE_COUNT) * Math.PI * 2 * 15; // Nhi·ªÅu v√≤ng xo·∫Øn
        const theta = (i / PARTICLE_COUNT) * Math.PI;
        const scale = 0.25;
        const x = 16 * Math.pow(Math.sin(phi), 3);
        const y = 13 * Math.cos(phi) - 5 * Math.cos(2*phi) - 2 * Math.cos(3*phi) - Math.cos(4*phi);
        const z = 6 * Math.cos(theta) * Math.sin(phi); // ƒê·ªô d√†y
        return { x: x * scale, y: y * scale, z: z * scale };
    }

    // H√¨nh Sao Th·ªï (H√†nh tinh + V√†nh ƒëai)
    function saturnShape(i) {
        if (i < PARTICLE_COUNT * 0.6) {
            // Ph·∫ßn th√¢n h√†nh tinh
            const phi = Math.acos(-1 + (2 * i) / (PARTICLE_COUNT * 0.6));
            const theta = Math.sqrt((PARTICLE_COUNT * 0.6) * Math.PI) * phi;
            const r = 2.2;
            return {
                x: r * Math.cos(theta) * Math.sin(phi),
                y: r * Math.sin(theta) * Math.sin(phi),
                z: r * Math.cos(phi)
            };
        } else {
            // Ph·∫ßn v√†nh ƒëai
            const angle = i * 0.05;
            const dist = 3.5 + Math.random() * 3; // B√°n k√≠nh v√†nh ƒëai
            return {
                x: Math.cos(angle) * dist,
                y: (Math.random() - 0.5) * 0.3, // ƒê·ªô m·ªèng c·ªßa v√†nh ƒëai
                z: Math.sin(angle) * dist
            };
        }
    }

    // H√¨nh B√¥ng hoa
    function flowerShape(i) {
        const u = (i / PARTICLE_COUNT) * Math.PI * 2;
        const k = 5; // S·ªë c√°nh hoa
        const r = 4 * Math.cos(k * u) + 1; // C√¥ng th·ª©c hoa h·ªìng c·ª±c
        const z = (Math.random() - 0.5) * 1.5;
        return {
            x: r * Math.cos(u),
            y: r * Math.sin(u),
            z: z
        };
    }

    // H√¨nh C∆°n b√£o/B√°nh v√≤ng (Torus)
    function torusShape(i) {
        const u = (i / PARTICLE_COUNT) * Math.PI * 2 * 8;
        const v = (i / PARTICLE_COUNT) * Math.PI * 2;
        const R = 4; // B√°n k√≠nh l·ªõn
        const r = 1.2; // B√°n k√≠nh ·ªëng
        return {
            x: (R + r * Math.cos(u)) * Math.cos(v),
            y: (R + r * Math.cos(u)) * Math.sin(v),
            z: r * Math.sin(u) * 2 // K√©o d√†i tr·ª•c Z ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng b√£o
        };
    }

    // --- QU·∫¢N L√ù TR·∫†NG TH√ÅI ---
    let currentShapeType = 1; // M·∫∑c ƒë·ªãnh l√† h√¨nh c·∫ßu
    let handX = 0;
    let handY = 0;
    let targetParticleSize = BASE_PARTICLE_SIZE;

    // C·∫≠p nh·∫≠t v·ªã tr√≠ m·ª•c ti√™u d·ª±a tr√™n h√¨nh d·∫°ng hi·ªán t·∫°i
    function updateTargets() {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let p;
            if (currentShapeType === 1) p = sphereShape(i);
            else if (currentShapeType === 2) p = heartShape(i);
            else if (currentShapeType === 3) p = saturnShape(i);
            else if (currentShapeType === 4) p = flowerShape(i);
            else p = torusShape(i);

            targets[i * 3] = p.x;
            targets[i * 3 + 1] = p.y;
            targets[i * 3 + 2] = p.z;
        }
    }
    updateTargets(); // G·ªçi l·∫ßn ƒë·∫ßu

    // --- X·ª¨ L√ù MEDIAPIPE HANDS ---
    const videoElement = document.getElementById('videoElement');
    const statusText = document.getElementById('status');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            statusText.innerText = "Tr·∫°ng th√°i: ƒê√£ nh·∫≠n di·ªán tay! ‚úã";
            statusText.style.color = "#00ff88";
            const landmarks = results.multiHandLandmarks[0];
            const fingerTip = landmarks[8]; // ƒê·∫ßu ng√≥n tr·ªè

            // 1. T√≠nh to√°n v·ªã tr√≠ tay (Map t·ª´ 0-1 sang to·∫° ƒë·ªô 3D)
            // ƒê·∫£o ng∆∞·ª£c X v√¨ video b·ªã g∆∞∆°ng
            handX = (1 - fingerTip.x) * 12 - 6; 
            handY = (1 - fingerTip.y) * 10 - 5; 

            // 2. ƒêI·ªÄU KHI·ªÇN M√ÄU S·∫ÆC (D·ª±a tr√™n v·ªã tr√≠ tay)
            // X ƒëi·ªÅu khi·ªÉn Hue (0h ƒë·∫øn 1h)
            const hue = 1 - fingerTip.x; 
            // Y ƒëi·ªÅu khi·ªÉn Lightness (cao = s√°ng, th·∫•p = t·ªëi)
            const lightness = THREE.MathUtils.mapLinear(fingerTip.y, 0, 1, 0.8, 0.2);
            const saturation = 0.9; // ƒê·ªô b√£o h√≤a m√†u cao
            
            material.color.setHSL(hue, saturation, lightness);

            // 3. ƒê·∫øm ng√≥n tay ƒë·ªÉ ƒë·ªïi h√¨nh
            let fingersUp = 0;
            // So s√°nh ƒë·ªânh ng√≥n tay v·ªõi kh·ªõp d∆∞·ªõi
            if (landmarks[4].x < landmarks[3].x) fingersUp++; // Ng√≥n c√°i (T∆∞∆°ng ƒë·ªëi)
            if (landmarks[8].y < landmarks[6].y) fingersUp++; // Ng√≥n tr·ªè
            if (landmarks[12].y < landmarks[10].y) fingersUp++; // Ng√≥n gi·ªØa
            if (landmarks[16].y < landmarks[14].y) fingersUp++; // Ng√≥n √°p √∫t
            if (landmarks[20].y < landmarks[18].y) fingersUp++; // Ng√≥n √∫t

            if (fingersUp > 0 && fingersUp <= 5 && fingersUp !== currentShapeType) {
                currentShapeType = fingersUp;
                updateTargets();
            }

            // 4. ƒêI·ªÄU KHI·ªÇN K√çCH C·ª† H·∫†T (Pinch Gesture)
            // T√≠nh kho·∫£ng c√°ch gi·ªØa ƒë·∫ßu ng√≥n c√°i [4] v√† ƒë·∫ßu ng√≥n tr·ªè [8]
            const dx = landmarks[4].x - landmarks[8].x;
            const dy = landmarks[4].y - landmarks[8].y;
            const pinchDist = Math.sqrt(dx*dx + dy*dy);
            
            // Map kho·∫£ng c√°ch pinch (kho·∫£ng 0.02 - 0.3) sang k√≠ch th∆∞·ªõc h·∫°t
            // Pinch g·∫ßn = nh·ªè, Pinch xa = to
            targetParticleSize = THREE.MathUtils.mapLinear(pinchDist, 0.02, 0.25, 0.02, 0.25);
            targetParticleSize = THREE.MathUtils.clamp(targetParticleSize, 0.01, 0.3); // Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc

        } else {
            statusText.innerText = "Tr·∫°ng th√°i: ƒêang t√¨m tay...";
            statusText.style.color = "#ffaa00";
            // T·ª± ƒë·ªông ƒë∆∞a v·ªÅ trung t√¢m v√† k√≠ch th∆∞·ªõc m·∫∑c ƒë·ªãnh n·∫øu m·∫•t d·∫•u tay
            handX = THREE.MathUtils.lerp(handX, 0, 0.05);
            handY = THREE.MathUtils.lerp(handY, 0, 0.05);
            targetParticleSize = THREE.MathUtils.lerp(targetParticleSize, BASE_PARTICLE_SIZE, 0.05);
            // T·ª´ t·ª´ chuy·ªÉn v·ªÅ m√†u xanh m·∫∑c ƒë·ªãnh
            material.color.lerp(new THREE.Color(0x00ffff), 0.05);
        }
    }

    // --- C·∫§U H√åNH MEDIAPIPE ---
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240 // ƒê·ªô ph√¢n gi·∫£i video th·∫•p ƒë·ªÉ x·ª≠ l√Ω nhanh
    });
    cameraUtils.start();


    // --- V√íNG L·∫∂P ANIMATION ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        const positionsArray = particles.geometry.attributes.position.array;

        // 1. C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc h·∫°t m∆∞·ª£t m√†
        material.size = THREE.MathUtils.lerp(material.size, targetParticleSize, 0.1);

        // 2. Di chuy·ªÉn h·∫°t ƒë·∫øn v·ªã tr√≠ m·ª•c ti√™u (Morphing)
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const px = i * 3; const py = i * 3 + 1; const pz = i * 3 + 2;

            // V·ªã tr√≠ ƒë√≠ch = V·ªã tr√≠ m·∫´u h√¨nh + V·ªã tr√≠ tay
            const tx = targets[px] + handX;
            const ty = targets[py] + handY; 
            const tz = targets[pz];

            // Th√™m ch√∫t nhi·ªÖu ƒë·ªông ƒë·ªÉ h·∫°t tr√¥ng s·ªëng ƒë·ªông h∆°n
            const noiseX = Math.sin(time * 1.5 + i * 0.1) * 0.03;
            const noiseY = Math.cos(time * 1.7 + i * 0.1) * 0.03;

            // H√†m Lerp ƒë·ªÉ di chuy·ªÉn m∆∞·ª£t m√†
            positionsArray[px] += (tx - positionsArray[px]) * LERP_SPEED + noiseX;
            positionsArray[py] += (ty - positionsArray[py]) * LERP_SPEED + noiseY;
            positionsArray[pz] += (tz - positionsArray[pz]) * LERP_SPEED;
        }

        // B·∫Øt bu·ªôc Three.js c·∫≠p nh·∫≠t l·∫°i v·ªã tr√≠
        particles.geometry.attributes.position.needsUpdate = true;
        
        // Xoay nh·∫π to√†n b·ªô h·ªá th·ªëng
        particles.rotation.y += 0.003;
        particles.rotation.x += Math.sin(time * 0.5) * 0.001;

        renderer.render(scene, camera);
    }

    // X·ª≠ l√Ω khi thay ƒë·ªïi k√≠ch th∆∞·ªõc m√†n h√¨nh
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>